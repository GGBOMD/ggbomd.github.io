---
layout: post
title: 第一次算法总结(2020年6月20日课时)
---

### 1. 0~n-1缺失的数字
#### 1.1 题目
  一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0~n-1之内。在范围0~n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数
字。
#### 1.2 简要分析
  对题目的部分隐藏要素的分析。首先是数组是包含0~n-1整形数据的有序数组，再者就是如果数字在不缺失的情况下与数组的下标是一致的，依据这个理由就可以做出这样
一个判断，例如缺失数字的下标为i，那么在目前位置上的必然是正常不缺失情况下i+1位置的数字。
#### 1.3 解答问题
  二分法对于这个问题的解决比较简便，易于理解，情况也比较少：
  判断获取到的中值下标是否与该中值是否相等，如若相等，说明左半部分没有问题，查找就从右半部分开始；如若不相等，这时将这个中间值的下标与前一个位置的值进行
比较，如果相等，说明前一个位置的下标就是缺失的数字，这时如果不等，就从左半部分开始查找。
![1. 0~n-1缺失的数字](/images/缺失的数字.JPG "缺失的数字代码截图")

### 2. 最长递增数列
#### 2.1 题目
  给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。
#### 2.2 简要分析
  对于这道题简单的思路就是循环遍历，对相邻位置(即i与i+1位置)进行比较，如果几个数连续出现递增的情况，这时就会使用定义的变量进行记录，由此获得当前递增数列的长度。
#### 2.3 解答问题
  使用Java进行问题的解答，这里用到了max()方法可返回两个指定的数中带有较大的值的那个数，定义两个参数，一个记录当前最长的递增数列长度max，一个记录当前递增数列的长度count，在遇到中断时，通过max()函数对max进行实时更新，如未遇到中断则在结尾使用max()进行判断返回。
![2. 最长递增数列](/images/最长递增数列.JPG "最长递增序列")
